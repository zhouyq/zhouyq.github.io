<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SA-Logs</title>
  <subtitle>拥抱开源，分享经验!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://salogs.com/"/>
  <updated>2018-08-01T08:18:49.000Z</updated>
  <id>https://salogs.com/</id>
  
  <author>
    <name>zhouyq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes 是如何成为传统应用迁移的终极方案的</title>
    <link href="https://salogs.com/news/2018/08/01/how-kubernetes-became-solution-migrating-legacy-applications/"/>
    <id>https://salogs.com/news/2018/08/01/how-kubernetes-became-solution-migrating-legacy-applications/</id>
    <published>2018-08-01T07:49:40.000Z</published>
    <updated>2018-08-01T08:18:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>其实你根本就没有必要将自己的单体应用改写为现代的版本，使用云原生技术可以将之优雅的转变为微服务架构。</p>
</blockquote>
<h1 id="计算机基础设施的变迁史"><a href="#计算机基础设施的变迁史" class="headerlink" title="计算机基础设施的变迁史"></a>计算机基础设施的变迁史</h1><p>在互联网的早期，如果你来运行应用程序的话，需要购买或租用硬件。无论它是机架式的还是塔式的服务器，这不重要，重要的是每一个应用都需要一台服务器来运行，所以是非常昂贵的。在2001年，VMware推出了虚拟化软件，允许用户在同一硬件上运行多个应用程序。这也就意味着将一台服务器分割为多个，而且分割后的服务器是完全可以独立运行应用程序的。这对于用户的成本来说，是极大的节约。</p>
<p>时间过得很快，转眼就是2006年，亚马逊普及了基础设施即服务（IaaS），因为推出了颠覆性服务——AWS的弹性计算云（EC2），你不再需要购买你自己的硬件。你甚至都不需要去担心管理那些运行你的应用程序的虚拟机。而你实际上正在租用运行你的服务所需的计算环境和底层基础架构。你按小时来付费，像租用开会用的会议室一样。这样就可以让使用它们的公司，能够充分的优化自己的资源以节约成本，只需购买自己所需要的计算资源即可。要知道，IaaS 的出现是具有革命性的变革的，它的直接结果就是让计算的成本下降很多。</p>
<p>三年之后，Heroku提出了平台即服务（PaaS）的想法。PaaS 通过屏蔽了需要管理虚拟机操作系统重新抽象了一层。Heroku神奇地简化了部署应用程序的新版本；让应用变成了只需要输入 git push heroku 这样简单的命令即可。在Heroku当时诞生了很多现在知名的互联网公司。</p>
<p>这些进步使得以任何规模（大或小）部署应用程序变得更加容易和成本低廉。这就直接导致了许多的创新出现，并极大的推动了企业在处理基础设施上的实质转变，从而将其从资本支出转移到可变的运营支出。</p>
<p>以上所有看起来一切都很美好，不知道读者看到这里是否意识到？这其中有一个非常大的问题。那就是所有的这些技术提供商都是闭源的、专有的公司。这就存在一个现象：单独厂家锁定！在各个环境之间移植应用程序是非常困难的事情。混合和匹配内部部署和基于云的应用程序几乎是不可能的。</p>
<p>而这个大问题就需要开源来解决！不过也是时机正好。这次依旧是基于Linux之上，即 Docker 和 Kubernetes，而后者更是被人们称之为云时代的Linux。</p>
<h1 id="开源来拯救世界"><a href="#开源来拯救世界" class="headerlink" title="开源来拯救世界"></a>开源来拯救世界</h1><p>Docker在2013年出现，将容器的概念迅速扩散。正如当年集装箱点燃了全球的货运革命一样，当时的船运公司使用这种大型的金属集装箱替代了过去纷杂的货运装置，以适应在卡车、船舶、铁路三者之间匹配。<strong>装什么无所谓，重要的是装载本身有了标准。</strong></p>
<p>和现实世界的集装箱运输一样，Docker 容器创建了对于应用最为基本的封装，使之可以运行在任何的基础设施平台上。一时之间，Linux容器风靡世界。到今天为止，几乎所有的企业都有意愿将他们的应用跑在容器之上，即使是他们自己的内部的服务器，也同样在考虑。尽管容器仅仅是管理现代的应用程序的一种更好的方式，因为它们通常被分割成无数的组件（微服务），但仍然需要能够在服务器之间进行容易的移植和访问。</p>
<p>技术的本质，通常是解决了一个问题，而又引入新的问题，如此反复。Linux容器也不例外，它虽然封装的很好，但是它给DevOps团队带来前所未有的挑战，它在应用程序的移植、部署的活动中增加的了更多动态的东西。于是Kubernetes应时而生。</p>
<p>2015年，Google 以开源的方式发布了Kubernetes项目，它是Google内部系统Borg的实现。Google 联合Linux基金会成立了云原生计算基金会（CNCF），Kubernetes是此基金会下的第一个种子项目，Kubernetes迅速成为历史上发展最快的开源项目之一，目前拥有数十家公司和组织中成千上万的贡献者。</p>
<p>是什么让Kubernetes如此不可思议的快速增长？恐怕最主要的原因莫过于Kubernetes是Google内部集群系统Borg的再现。这个世界上还很少有哪家的数据中心有Google的规模，Borg 系统平均每周会推出大约20亿个容器，这也就是说每秒钟都会新启动3300个容器。大家可以想象一下高峰期的时候，会比这个数字大得多。是的，没错，Kubernetes就是诞生在这样一个强大的系统之上的，经历过严峻考验的、以应对比这个规模更大的负载！</p>
<p><img src="1_cncf-history.png" alt=""></p>
<p>在确定了 Docker 和 Kubernetes 作为核心之后，CNCF扩展了更多的云原生项目，到目前为止，CNCF拥有大大小小的项目数量达到了369，其中较为重要和成熟的项目有：<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a>, <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>, <a href="http://opentracing.io/" target="_blank" rel="noopener">OpenTracing</a>, <a href="https://www.fluentd.org/" target="_blank" rel="noopener">Fluentd</a>, <a href="https://linkerd.io/" target="_blank" rel="noopener">Linkerd</a>, <a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a>, <a href="https://coredns.io/" target="_blank" rel="noopener">CoreDNS</a>, <a href="https://coreos.com/rkt/" target="_blank" rel="noopener">rkt</a>, <a href="https://containerd.io/" target="_blank" rel="noopener">containerd</a>, <a href="https://www.cncf.io/blog/2017/05/23/cncf-hosts-container-networking-interface-cni/" target="_blank" rel="noopener">Container Networking Interface</a>, <a href="https://github.com/coredns?language=css" target="_blank" rel="noopener">CoreDNS</a>, <a href="https://envoy.com/" target="_blank" rel="noopener">Envoy</a>, <a href="https://github.com/jaegertracing/jaeger" target="_blank" rel="noopener">Jaeger</a>, <a href="https://github.com/theupdateframework/notary" target="_blank" rel="noopener">Notary</a>, <a href="https://github.com/theupdateframework/specification" target="_blank" rel="noopener">The Update Framework</a>, <a href="https://rook.io/" target="_blank" rel="noopener">Rook</a>, 和 <a href="http://vitess.io/" target="_blank" rel="noopener">Vitess</a>.</p>
<p><img src="2_cncf-landscape.jpg" alt=""></p>
<p>然而，作为后起之秀的CNCF，从以往过去的开源项目汲取了很多的经验，CNCF一直非常谨慎，以确保只选择那些能够很好地协同工作并能满足企业和创业公司需求的技术。而且这些技术正在大量采用。</p>
<p>企业拥抱开源技术最大的原因之一就是避免供应商锁定，并实现在多个云平台之间，以及云平台和私有的基础设施之间的容器的平滑移植。基于开源，最终用户可以很容器的切换供应商，也可以使用混合的云平台。如果用户拥有足够的技术能力，甚至都可以自己来进行管理。</p>
<h2 id="将单体应用分片"><a href="#将单体应用分片" class="headerlink" title="将单体应用分片"></a>将单体应用分片</h2><p>Kubernetes和Docker 不仅增强了用户管理大规模负载的能力，而且还能够将大型的、单体应用更加容易的分割为更加易于管理的微服务。分割之后的服务，具备自我管理的功能，可以随时根据需要进行伸缩。微服务还支持更快的部署和更快的迭代，以符合现代持续集成实践。基于Kubernetes的业务流程可以通过动态管理和调度这些微服务来提高效率和资源利用率。它还增加了非凡的弹性水平。用户根本不必担心容器故障，且可以继续按需求进行伸缩。</p>
<p>Kubernetes 迅速成为云原生编排系统的首选，它也成为了开源历史上速度最快的开发项目之一。并得到包括AWS，微软，红帽，SUSE等在内的主要厂商的支持。</p>
<p>所有这些都对企业有直接的影响。具Puppet公司举行的2016年度DevOps形势报告称，高性能的云原生架构可以有更频繁的开发，更短的交付周期，更低的故障率以及更快的故障恢复。这意味着功能可以更快地推向市场，项目可以更快地发挥作用，而工程和开发团队的等待时间则少得多。在今天，如果您要从头开始构建新的应用程序，那么云原生应用程序体系结构就是实现它的最佳途径。同样重要的是，云原生会思考如何利用现有（棕地）应用程序提供了一个路线图，并将它们慢慢转化为运行在容器和Kubernetes上的更为高效和更具弹性的基于微服务的架构。棕地、单体应用其实是构成当今所有软件产品的大部分内容。</p>
<p>单体应用是站在云原生应用的对立面的，它们意味着的陈旧、代价昂贵、臃肿、紧耦合、且不够稳定。问题在于:<strong>如何将这些单体应用拆分为微服务架构？</strong> 用户或许考虑过重写所有的那些大型的旧版应用，而现实的情况告诉你：<strong>大多数重写都以失败告终。</strong>你试图重写的第一个系统，即使在你试图替换它时也是存在的，而且一直都在进化。有时候，第一个系统发展得太快，你永远无法赶上。</p>
<p>当然，用户也可以采用更加有效的方法来解决此问题。首先，停止向现有的单体应用程序添加重要的新功能。这里有一个“提升和转移”的概念，也就意味着用户可以将一个需要几GB内存的应用使用容器来封装。是不是很简单！</p>
<h1 id="一个将单体应用转换为容器的典型实例"><a href="#一个将单体应用转换为容器的典型实例" class="headerlink" title="一个将单体应用转换为容器的典型实例"></a>一个将单体应用转换为容器的典型实例</h1><p><a href="https://www.youtube.com/watch?v=dUHr2ukGN5w&amp;list=PLbzoR-pLrL6oNLRbC03ziuX0JWzQFjnth&amp;index=28" target="_blank" rel="noopener">Ticketmaster</a> 就是实现单体应用转换为容器典型的实例。它的代码运行在非常古老的<a href="https://en.wikipedia.org/wiki/PDP-11" target="_blank" rel="noopener">PDP-11</a>中，首先将创建了一个PDP-11的模拟器，然后使其在Docker中运行，这样就间接的将应用也容器化了。我们知道Kubernetes有一项功能叫做<a href="https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/" target="_blank" rel="noopener">Stateful set</a>（也就是过去的PetSets），此功能可以将某些容器固定的运行在特定的机器中，以确保它能够保持正常运行。</p>
<p>另外，Ticketmaster 还有一个特殊的问题：每当开始售票的时候，当所有人都来访问的时候，这无异于就是发动了分布式拒绝服务（DDoS）攻击。该公司需要一套前端服务器，可以扩展和处理这种需求，而不是试图将其写入他们的旧版应用程序中。最终的解决办法是,在旧版应用程序的前面部署了一套新的基于容器的微服务，进而最大限度地减少了传统体系结构中的持续蔓延。</p>
<p>当你试图将工作负载从旧版程序迁移到容器的时候，可能还想将某些功能从应用程序转移到微服务中，又或者是使用微服务来添加新的功能，而不是添加到旧的代码库中。举个例子，如果您想添加<a href="https://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a>这项功能，可能只需一个简单的<a href="https://opensource.com/tags/nodejs" target="_blank" rel="noopener">Node.js</a>应用程序可以放在你的旧版应用程序前面即可。如果你有一个高性能敏感的任务，你可以在Golang中编写它，并将其设置为一个驻留的单体应用前，使得API驱动的服务能够生效。仍然可以将API调用返回到你现有的单体应用。</p>
<p>这些新功能可以由不同的团队用更现代的语言编写，这些团队可以使用自己的一套库和依赖关系，并开始拆分原有的单体应用。</p>
<p>来自北卡罗来纳的<a href="https://www.key.com/personal/index.jsp" target="_blank" rel="noopener">KeyBanc</a>无疑是这方面最为生动的案例，它在传统的Java应用程序之前部署Node.js应用程序服务器来处理移动客户端。这比为旧版单体应用添加代码，显得更为简单，也更高效，而且有助于确保其基础架构在未来也能良性发展。</p>
<h1 id="真正的云原生是众多项目互补的集合"><a href="#真正的云原生是众多项目互补的集合" class="headerlink" title="真正的云原生是众多项目互补的集合"></a>真正的云原生是众多项目互补的集合</h1><p>如果作为用户的你正在打算拥抱云原生技术的话，那么就应该考虑一下项目互补来交付核心的功能。举个例子，在云原生的环境中，最重要的莫过于监视、追踪和日志。此时就可以考虑诸如Prometheus、OpenTracing 和 Fluentd，Linkerd 是一个service mesh，其可以支持更复杂的路由。gRPC是一个非常高性能的API系统，完全可以替代原有的JSON，且获得更高性能。CoreDNS是一个服务发现平台。所有这些项目均是CNCF的一分子，在未来CNCF会增加更多的项目，为拥抱云原生技术的用户拥有更多选择。</p>
<h1 id="无论是绿地、棕地，还是其它什么地，均可云原生"><a href="#无论是绿地、棕地，还是其它什么地，均可云原生" class="headerlink" title="无论是绿地、棕地，还是其它什么地，均可云原生"></a>无论是绿地、棕地，还是其它什么地，均可云原生</h1><p>作为开发者的你，或许此时会考虑迁移旧有的单体应道到云原生的微服务，那么恭喜你，你根本毋须完全另起炉灶新写一个，或者重新改写。诸如 Kubernetes 这样的CNCF技术非常拥抱旧有的应用程序，这对于所有的公司和企业来说，都是应该走的进化之路。用户既可以使用Kubernetes来构建一套全新的应用，也可以逐步的将原有的单体应用转化为微服务应用，以在不久的未来担当重要业务的支撑。</p>
<blockquote>
<p><strong>注解：</strong> 关于绿地（greenfeild)棕地（brownfeild)的解释： 绿地是指软件完全是不受任何原有系统干扰的新的项目，而棕地则表示，在开发新的系统时，要处处引进和考虑旧的系统。</p>
</blockquote>
<p>关于原作者</p>
<blockquote>
<p>Swapnil Bhartiya 是一名专业的记者和编辑，有超过报道企业开源12年的职业经历。</p>
<p>本文由作者Swapnil Bhartiya 发表在Opensource.com上：<a href="https://opensource.com/article/18/2/how-kubernetes-became-solution-migrating-legacy-applications" target="_blank" rel="noopener">How Kubernetes became the solution for migrating legacy applications</a>。由开源之道精心翻译共享。本文在Creative Commons BY-SA 4.0许可证下发布。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实你根本就没有必要将自己的单体应用改写为现代的版本，使用云原生技术可以将之优雅的转变为微服务架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;计算机基础设施的变迁史&quot;&gt;&lt;a href=&quot;#计算机基础设施的变迁史&quot; class=&quot;head
    
    </summary>
    
      <category term="Kubernetes" scheme="https://salogs.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://salogs.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7.x 安装 Dell OMSA 与监控</title>
    <link href="https://salogs.com/news/2018/06/21/install-dell-omsa/"/>
    <id>https://salogs.com/news/2018/06/21/install-dell-omsa/</id>
    <published>2018-06-21T06:44:44.000Z</published>
    <updated>2018-06-21T08:00:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>各大厂商的服务器都有配到的硬件管理及监控软件，本文主要针对Dell服务器，讲解它的管理与监控。</p>
<p>Dell服务器的 OMSA （OpenManage Server Administrator ）是安装在操作系统中的一套软件，提供硬件监控、驱动程序的升级等操作。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>配置仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="_">-s</span> http://linux.dell.com/repo/hardware/dsu/bootstrap.cgi | bash</span><br></pre></td></tr></table></figure>
<ul>
<li>安装DSU(Dell EMC System Update)<blockquote>
<p>DSU 是为操作更新驱动与软件的服务。</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install dell-system-update</span><br></pre></td></tr></table></figure>
<ul>
<li>安装并启动OMSA</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install srvadmin-all -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">/opt/dell/srvadmin/sbin/srvadmin-services.sh <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">/opt/dell/srvadmin/sbin/srvadmin-services.sh start</span><br><span class="line">Starting instsvcdrv (via systemctl):                       [  确定  ]</span><br><span class="line">Starting dataeng (via systemctl):                          [  确定  ]</span><br><span class="line">Starting dsm_om_connsvc (via systemctl):                   [  确定  ]</span><br></pre></td></tr></table></figure>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>安装完OMSA后，可以通过访问 https://&lt;本机IP&gt;:000 通过浏览器的方式查看硬件信息，如果机器成百上千台，这种方式的工作效率是非常低的，因此本文介绍通过<code>nagios</code>插件 <a href="http://folk.uio.no/trondham/software/check_openmanage.html" target="_blank" rel="noopener">check_openmanage</a> 的方式通过命令行检查，当然这个插件可以结合nagios和zabbix使用，有兴趣的同学可以深入学习一下。 下文只简单介绍使用方法</p>
<h3 id="下载check-openmanage"><a href="#下载check-openmanage" class="headerlink" title="下载check_openmanage"></a>下载check_openmanage</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://folk.uio.no/trondham/software/files/check_openmanage-3.7.12.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="使用check-openmanage"><a href="#使用check-openmanage" class="headerlink" title="使用check_openmanage"></a>使用check_openmanage</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./check_openmanage -h</span><br><span class="line">Usage: check_openmanage [OPTION]...</span><br><span class="line"></span><br><span class="line">GENERAL OPTIONS:</span><br><span class="line"></span><br><span class="line">   <span class="_">-f</span>, --config         Specify configuration file</span><br><span class="line">   -p, --perfdata       Output performance data [default=no]</span><br><span class="line">   -t, --timeout        Plugin timeout <span class="keyword">in</span> seconds [default=30]</span><br><span class="line">   -c, --critical       Custom temperature critical limits</span><br><span class="line">   -w, --warning        Custom temperature warning limits</span><br><span class="line">   -F, --fahrenheit     Use Fahrenheit as temperature unit</span><br><span class="line">   <span class="_">-d</span>, --debug          Debug output, reports everything</span><br><span class="line">   -h, --help           Display this <span class="built_in">help</span> text</span><br><span class="line">   -V, --version        Display version info</span><br><span class="line"></span><br><span class="line">SNMP OPTIONS:</span><br><span class="line"></span><br><span class="line">   -H, --hostname       Hostname or IP (required <span class="keyword">for</span> SNMP)</span><br><span class="line">   -C, --community      SNMP community string [default=public]</span><br><span class="line">   -P, --protocol       SNMP protocol version [default=2c]</span><br><span class="line">   --port               SNMP port number [default=161]</span><br><span class="line">   -6, --ipv6           Use IPv6 instead of IPv4 [default=no]</span><br><span class="line">   --tcp                Use TCP instead of UDP [default=no]</span><br><span class="line"></span><br><span class="line">OUTPUT OPTIONS:</span><br><span class="line"></span><br><span class="line">   -i, --info           Prefix any alerts with the service tag</span><br><span class="line">   <span class="_">-e</span>, --extinfo        Append system info to alerts</span><br><span class="line">   <span class="_">-s</span>, --state          Prefix alerts with alert state</span><br><span class="line">   -S, --short-state    Prefix alerts with alert state abbreviated</span><br><span class="line">   -o, --okinfo         Verbosity when check result is OK</span><br><span class="line">   -B, --show-blacklist Show blacklistings <span class="keyword">in</span> OK output</span><br><span class="line">   -I, --htmlinfo       HTML output with clickable links</span><br><span class="line"></span><br><span class="line">CHECK CONTROL AND BLACKLISTING:</span><br><span class="line"></span><br><span class="line">   <span class="_">-a</span>, --all            Check everything, even <span class="built_in">log</span> content</span><br><span class="line">   -b, --blacklist      Blacklist missing and/or failed components</span><br><span class="line">   --only               Only check a certain component or alert <span class="built_in">type</span></span><br><span class="line">   --check              Fine-tune <span class="built_in">which</span> components are checked</span><br><span class="line">   --no-storage         Don<span class="string">'t check storage</span></span><br><span class="line"><span class="string">   --vdisk-critical     Make any alerts on virtual disks critical</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information and advanced options, see the manual page or URL:</span></span><br><span class="line"><span class="string">  http://folk.uio.no/trondham/software/check_openmanage.html</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各大厂商的服务器都有配到的硬件管理及监控软件，本文主要针对Dell服务器，讲解它的管理与监控。&lt;/p&gt;
&lt;p&gt;Dell服务器的 OMSA （OpenManage Server Administrator ）是安装在操作系统中的一套软件，提供硬件监控、驱动程序的升级等操作。&lt;
    
    </summary>
    
      <category term="linux" scheme="https://salogs.com/categories/linux/"/>
    
      <category term="monitor" scheme="https://salogs.com/categories/linux/monitor/"/>
    
    
      <category term="Hardware" scheme="https://salogs.com/tags/Hardware/"/>
    
      <category term="monitor" scheme="https://salogs.com/tags/monitor/"/>
    
  </entry>
  
  <entry>
    <title>开源PaaS Rainbond不完全评测01 —— 安装篇</title>
    <link href="https://salogs.com/news/2018/06/21/rainbond-install-s1/"/>
    <id>https://salogs.com/news/2018/06/21/rainbond-install-s1/</id>
    <published>2018-06-21T04:50:57.000Z</published>
    <updated>2018-06-21T06:53:15.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac 安装与使用Shadowsocks</title>
    <link href="https://salogs.com/news/2016/11/02/mac-shadowsocks/"/>
    <id>https://salogs.com/news/2016/11/02/mac-shadowsocks/</id>
    <published>2016-11-02T04:31:17.000Z</published>
    <updated>2016-11-02T08:37:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>A secure socks5 proxy,designed to protect your Internet traffic.—— 来自 <a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">shadowsocks.org</a></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><strong>速度快</strong> 程序基于异步I/O和事件驱动研发</li>
<li><strong>灵活的加密方式</strong> 使用行业级加密算法加密。 灵活支持自定义算法。</li>
<li><strong>移动设备支持</strong> 针对移动和无线网络进行优化，没有任何保持活动的连接请求。</li>
<li><strong>跨平台</strong> 支持主流平台，包括Windows, Linux, Mac, Android, iOS, 和 OpenWRT。</li>
<li><strong>开放源码</strong> 完全免费和开源。全球开发者社区解决程序bug，免费代码，长效支持！</li>
<li><strong>易于开发</strong> 可以通过 pip, aur, freshports 和其他包管理系统实现简单开发</li>
</ul>
<h2 id="安装Shadowsocks-Server"><a href="#安装Shadowsocks-Server" class="headerlink" title="安装Shadowsocks-Server"></a>安装Shadowsocks-Server</h2><p>这里只介绍Ubuntu/Debian系统安装 Server 端程序</p>
<p>先添加 GPG public key :<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -O- http://shadowsocks.org/debian/1D27208A.gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></p>
<p>配置包仓库地址<br>Debian Wheezy, Ubuntu 12.04 系统 libssl &gt; 1.0.0 执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"deb http://shadowsocks.org/debian wheezy main"</span> &gt;&gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>如果操作系统是 Debian Squeeze, Ubuntu 11.04, libssl &gt; 0.9.8, but &lt; 1.0.0 执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"deb http://shadowsocks.org/debian squeeze main"</span> &gt;&gt; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>然后安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install shadowsocks-libev</span><br></pre></td></tr></table></figure>
<h2 id="Mac系统安装-Shadowsocks-Client"><a href="#Mac系统安装-Shadowsocks-Client" class="headerlink" title="Mac系统安装 Shadowsocks-Client"></a>Mac系统安装 Shadowsocks-Client</h2><ul>
<li><p>安装GUI 客户端<br>下载地址：<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a></p>
</li>
<li><p>通过命令行安装</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install shadowsocks-libev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">  brew services start shadowsocks-libev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者先前台跑一次程序</span></span><br><span class="line">/usr/<span class="built_in">local</span>/opt/shadowsocks-libev/bin/ss-local -c /usr/<span class="built_in">local</span>/etc/shadowsocks-libev.json</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;A secure socks5 proxy,designed to protect your Internet traffic.—— 来自 
    
    </summary>
    
    
      <category term="shadowsocks" scheme="https://salogs.com/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Hexo网站优化之SEO</title>
    <link href="https://salogs.com/news/2016/09/06/nexo-seo/"/>
    <id>https://salogs.com/news/2016/09/06/nexo-seo/</id>
    <published>2016-09-06T04:01:23.000Z</published>
    <updated>2016-09-06T04:11:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>SEO (Search Engine Optimization)，即搜索引擎优化。对网站做SEO优化，有利于提高搜索引擎的收录速度及网页排名。下面讲解一些简单的SEO优化方法，主要针对Hexo网站。</p>
<h1 id="SEO优化之title"><a href="#SEO优化之title" class="headerlink" title="SEO优化之title"></a>SEO优化之title</h1><p>编辑站点目录下的<code>themes/layout/index.swig</code>文件，将下面的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endlock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endlock %&#125;</span><br></pre></td></tr></table></figure>
<p>这时将网站的描述及关键词加入了网站的title中，更有利于详细地描述网站。</p>
<h1 id="添加robots-txt"><a href="#添加robots-txt" class="headerlink" title="添加robots.txt"></a>添加robots.txt</h1><p>robots.txt是一种存放于网站根目录下的ASCII编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。robots.txt应该放在站点目录下的source文件中，网站生成后在网站的根目录(<code>站点目录/public/</code>)下。</p>
<p>我的robots.txt文件内容如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /about/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br></pre></td></tr></table></figure></p>
<h1 id="添加sitemap"><a href="#添加sitemap" class="headerlink" title="添加sitemap"></a>添加sitemap</h1><p>Sitemap即网站地图，它的作用在于便于搜索引擎更加智能地抓取网站。最简单和常见的sitemap形式，是XML文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新时间、更新的频率及相对其他网址重要程度等）。</p>
<h2 id="Step-1-安装sitemap生成插件"><a href="#Step-1-安装sitemap生成插件" class="headerlink" title="Step 1: 安装sitemap生成插件"></a>Step 1: 安装sitemap生成插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<h2 id="Step-2-编辑站点目录下的-config-yml，添加"><a href="#Step-2-编辑站点目录下的-config-yml，添加" class="headerlink" title="Step 2: 编辑站点目录下的_config.yml，添加"></a>Step 2: 编辑站点目录下的_config.yml，添加</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo sitemap网站地图</span><br><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<h2 id="Step-3-在robots-txt文件中添加"><a href="#Step-3-在robots-txt文件中添加" class="headerlink" title="Step 3: 在robots.txt文件中添加"></a>Step 3: 在robots.txt文件中添加</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sitemap: http://www.jeyzhang.com/sitemap.xml</span><br><span class="line">Sitemap: http://www.jeyzhang.com/baidusitemap.xml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文转自：<a href="http://www.jeyzhang.com/hexo-website-seo.html" target="_blank" rel="noopener">http://www.jeyzhang.com/hexo-website-seo.html</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SEO (Search Engine Optimization)，即搜索引擎优化。对网站做SEO优化，有利于提高搜索引擎的收录速度及网页排名。下面讲解一些简单的SEO优化方法，主要针对Hexo网站。&lt;/p&gt;
&lt;h1 id=&quot;SEO优化之title&quot;&gt;&lt;a href=&quot;#SE
    
    </summary>
    
      <category term="经验分析" scheme="https://salogs.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E6%9E%90/"/>
    
    
      <category term="hexo,seo" scheme="https://salogs.com/tags/hexo-seo/"/>
    
  </entry>
  
  <entry>
    <title>GitHub开源的MySQL在线更改Schema工具</title>
    <link href="https://salogs.com/news/2016/08/03/gitHub-gh-ost-online-change-schema-tool/"/>
    <id>https://salogs.com/news/2016/08/03/gitHub-gh-ost-online-change-schema-tool/</id>
    <published>2016-08-03T07:46:26.000Z</published>
    <updated>2016-08-05T03:12:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL在线更改schema的工具很多，如Percona的<a href="https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html" target="_blank" rel="noopener">pt-online-schema-change</a>、 Facebook的 <a href="https://www.facebook.com/notes/mysql-at-facebook/online-schema-change-for-mysql/430801045932/" target="_blank" rel="noopener">OSC</a> 和 <a href="https://github.com/soundcloud/lhm" target="_blank" rel="noopener">LHM</a> 等，但这些都是基于触发器（Trigger）的，今天咱们介绍的 <code>gh-ost</code> 号称是不需要触发器（Triggerless）支持的在线更改表结构的工具。</p>
<p><img src="/img/gh-ost.png" alt="gh-ost"></p>
<p>原文地址：<a href="http://githubengineering.com/gh-ost-github-s-online-migration-tool-for-mysql/" target="_blank" rel="noopener">gh-ost: GitHub’s online schema migration tool for MySQL</a></p>
<blockquote>
<p>本文先介绍一下当前业界已经存在的这些工具的使用场景和原理，然后再详细介绍  <code>gh-ost</code> 的工作原理和特性。</p>
</blockquote>
<p>今天我们开源了GitHub内部使用的一款 不需要触发器支持的 MySQL 在线更改表结构的工具 <a href="http://github.com/github/gh-ost" target="_blank" rel="noopener">gh-ost</a></p>
<p>开发 <code>gh-ost</code> 是为了应付GitHub在生产环境中面临的持续的、不断变化的在线修改表结构的需求。<code>gh-ost</code> 通过提供低影响、可控、可审计和操作友好的解决方案改变了现有的在线迁移表工具的工作模式。</p>
<p>MySQL表迁移及结构更改操作是业界众所周知的问题，2009年以来已经可以通过在线（不停服务）变更的工具来解决。迅速增长，快速迭代的产品往往需要频繁的需改数据库的结构。增加/更改/删除/ 字段和索引等等，这些操作在MySQL中默认都会锁表，影响线上的服务。 向这种数据库结构层面的变更我们每天都会面临多次，当然这种操作不应该影响用户的正常服务。</p>
<p>在开始介绍 <code>gh-ost</code> 工具之前，咱们先来看一下当前现有的这些工具的解决方案。</p>
<h1 id="在线修改表结构，已存在的场景"><a href="#在线修改表结构，已存在的场景" class="headerlink" title="在线修改表结构，已存在的场景"></a>在线修改表结构，已存在的场景</h1><p>如今，在线修改表结构可以通过下面的三种方式来完成：</p>
<ul>
<li>在从库上修改表结构，操作会在其他的从库上生效，将结构变更了的从库设置为主库</li>
<li>使用 MySQL  InnoDB 存储引擎提供的在线DDL特性</li>
<li>使用在线修改表结构的工具。现在最流行的是 <a href="https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html" target="_blank" rel="noopener">pt-online-schema-change</a> 和 Facebook 的 <a href="https://www.facebook.com/notes/mysql-at-facebook/online-schema-change-for-mysql/430801045932/" target="_blank" rel="noopener">OSC</a>；当然还有 <a href="https://github.com/soundcloud/lhm" target="_blank" rel="noopener">LHM</a> 和比较原始的  <a href="http://shlomi-noach.github.io/openarkkit/oak-online-alter-table.html" target="_blank" rel="noopener">oak-online-alter-table</a> 工具。 </li>
</ul>
<p>其他的还包括 Galera 集群的Schema滚动更新，以及一些其他的非InnoDB的存储引擎等待，在 GitHub 我们使用通用的 主-从 架构 和  InnoDB 存储引擎。</p>
<p>为什么我们决定开始一个新的解决方案，而不是使用上面的提到的这些呢？现有的每种解决方案都有其局限性，下文会对这些方式的普遍问题简单的说明一下，但会对基于触发器的在线变更工具的问题进行详细说明。</p>
<ul>
<li><p>基于主从复制的迁移方式需要很多的前置工作，如：大量的主机，较长的传输时间，复杂的管理等等。变更操作需要在一个指定的从库上或者基于sub-tree的主从结构中执行。需要的情况也比较多，如：主机宕机、主机从早先的备份中恢复数据、新主机加入到集群等等，所有这些情况都有可能对我们的操作造成影响。最要命的是可能这些操作一天要进行很多次，如果使用这种方法我们操作人员每天的效率是非常高的（译者注：现如今很少有人用这种方式了吧）</p>
</li>
<li><p>MySQL针对Innodb存储引擎的在线DDL操作在开始之前都需要一个短时间排它锁(exclusive)来准备环境，所以alter命令发出后，会首先等待该表上的其它操作完成，在alter命令之后的请求会出现等待waiting meta data lock。同样在ddl结束之前，也要等待alter期间所有的事务完成，也会堵塞一小段时间，这对于繁忙的数据库服务来说危险系数是非常高的。另外DDL操作不能中断，如果中途kill掉，会造成长时间的事务回滚，还有可能造成元数据的损坏。它操作起来并不那么的Nice，不能限流和暂停，在大负载的环境中甚至会影响正常的业务。</p>
</li>
<li><p>我们用了很多年的 <code>pt-online-schema-change</code> 工具。然而随着我们不断增长的业务和流量，我们遇到了很多的问题，我们必须考虑在操作中的哪些 <code>危险操作</code> （译者注：pt工具集的文档中经常会有一些危险提示）。某些操作必须避开高峰时段来进行，否则MySQL可能就挂了。所有现存的在线表结构修改的工具都是利用了MySQL的触发器来执行的，这种方式有一些潜藏的问题。</p>
</li>
</ul>
<h1 id="基于触发器的在线修改有哪些问题呢？"><a href="#基于触发器的在线修改有哪些问题呢？" class="headerlink" title="基于触发器的在线修改有哪些问题呢？"></a>基于触发器的在线修改有哪些问题呢？</h1><p>所有在线表结构修改工具的操作方式都类似：创建与原表结构一致的临时表，该临时表已经是按要求修改后的表结构了，缓慢增量的从原表中复制数据，同时记录原表的更改(所有的 INSERT, DELETE, UPDATE 操作) 并应用到临时表。当工具确认表数据已经同步完成，它会进行替换工作，将临时表更名为原表。</p>
<p><code>pt-online-schema-change</code>, <code>LHM</code> 和 <code>oak-online-alter-table</code> 这些工具都使用同步的方式，当原表有变更操作时利用一些事务的间隙时间将这些变化同步到临时表。Facebook 的工具使用异步的方式将变更写入到changelog表中，然后重复的将changelog表的变更应用到临时表。所有的这些工具都使用触发器来识别原表的变更操作。</p>
<p>当表中的每一行数据有 INSERT, DELETE, UPDATE 操作时都会调用存储的触发器。一个触发器可能在一个事务空间中包含一系列查询操作。这样就会造成一个原子操作不单会在原表执行，还会调用相应的触发器执行多个操作。</p>
<p>在基于触发器迁移实践中，遇到了如下的问题：</p>
<ul>
<li><p>触发器是以解释型代码的方式保存的。MySQL 不会预编译这些代码。 会在每次的事务空间中被调用，它们被添加到被操作的表的每个查询行为之前的分析和解释器中。</p>
</li>
<li><p>锁表: 触发器在原始表查询中共享相同的事务空间，而这些查询在这张表中会有竞争锁，触发器在另外一张表会独占竞争锁。在这种极端情况下，同步方式的锁争夺直接关系到主库的并发写性能。以我们的经验来说，在生产环境中当竞争锁接近或者结束时，数据库可能会由于竞争锁而被阻塞住。触发锁的另一个方面是创建或销毁时所需要的元数据锁。我们曾经遇到过在繁忙的表中当表结构修改完成后，删除触发器可能需要数秒到分钟的时间。</p>
</li>
</ul>
<ul>
<li><p>不可信：当主库的负载上升时，我们希望降速或者暂停操作，但基于触发器的操作并不能这么做。虽然它可以暂停行复制操作，但却不能暂停出触发器，如果删除触发器可能会造成数据丢失，因此触发器需要在整个操作过程中都要存在。在我们比较繁忙的服务器中就遇到过由于触发器占用CPU资源而将主库拖死的例子。</p>
</li>
<li><p>并发迁移:  我们或者其他的人可能比较关注多个同时修改表结构（不同的表）的场景。鉴于上述触发器的开销，我们没有兴趣同时对多个表进行在线修改操作，我们也不确定是否有人在生产环境中这样做过。</p>
</li>
<li><p>测试：我们修改表结构可能只是为了测试，或者评估其负载开销。基于触发器的表结构修改操作只能通过基于语句复制的方式来进行模拟实验，离真实的主库操作还有一定的距离，不能真实的反映实际情况。</p>
</li>
</ul>
<h1 id="gh-ost"><a href="#gh-ost" class="headerlink" title="gh-ost"></a>gh-ost</h1><p><code>gh-ost</code>  GitHub 的在线 Schema 修改工具，下面工作原理图：</p>
<p> <img src="/img/gh-ost2.png" alt="gh-ost2"></p>
<p><code>gh-ost</code> 具有如下特性:</p>
<ul>
<li>无触发器</li>
<li>轻量级</li>
<li>可暂停</li>
<li>可动态控制</li>
<li>可审计</li>
<li>可测试</li>
<li>值得信赖 :blush:</li>
</ul>
<h1 id="无触发器"><a href="#无触发器" class="headerlink" title="无触发器"></a>无触发器</h1><p><code>gh-ost</code> 没有使用触发器。它通过分析binlog日志的形式来监听表中的数据变更。因此它的工作模式是异步的，只有当原始表的更改被提交后才会将变更同步到临时表（ghost table）</p>
<p><code>gh-ost</code> 要求binlog是RBR格式 ( 基于行的复制)；然而也不是说你就不能在基于SBR（基于语句的复制）日志格式的主库上执行在线变更操作。实际上是可以的。gh-ost 可以将从库的 SBR日志转换为RBR日志，只需要重新配置就可以了。</p>
<h1 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h1><p>由于没有使用触发器，因此在操作的过程中对主库的影响是最小的。当然在操作的过程中也不用担心并发和锁的问题。 变更操作都是以流的形式顺序的写到binlog文件中，gh-ost只是读取他们并应用到gh-ost表中。实际上，gh-ost 通过读取binlog的写事件来进行顺序的行复制操作。因此，主库只会有一个单独连接顺序的将数据写入到临时表（ghost table）。这和ETL操作有很大的不同。</p>
<h1 id="可暂停"><a href="#可暂停" class="headerlink" title="可暂停"></a>可暂停</h1><p>所有的写操作都是由gh-ost控制的，并且以异步的方式读取binlog，当限速的时候，gh-ost可以暂停向主库写入数据，限速意味着不会在主库进行复制，也不会有行更新。当限速时gh-ost会创建一个内部的跟踪（tracking）表，以最小的系统开销向这个表中写入心跳事件</p>
<p>gh-ost 支持多种方式的限速：</p>
<ul>
<li>负载: 为熟悉 <code>pt-online-schema-change</code> 工具的用户提供了类似的功能，可以设置MySQL中的状态阈值，如 Threads_running=30</li>
<li>复制延迟: <code>gh-ost</code> 内置了心跳机制，可以指定不同的从库，从而对主从的复制延迟时间进行监控，如果达到了设定的延迟阈值程序会自动进入限速模式。</li>
<li>查询: 用户可以可以设置一个限流SQL，比如 <code>SELECT HOUR(NOW()) BETWEEN 8 and 17</code> 这样就可以动态的设置限流时间。</li>
<li>标示文件: 可以通过创建一个标示文件来让程序限速，当删除文件后可以恢复正常操作。</li>
<li>用户命令: 可以动态的连接到 <code>gh-ost</code> (下文会提到) 通过网络连接的方式实现限速。</li>
</ul>
<h1 id="可动态控制"><a href="#可动态控制" class="headerlink" title="可动态控制"></a>可动态控制</h1><p>现在的工具，当执行操作的过程中发现负载上升了，DBA不得不终止操作，重新配置参数，如 chunk-size，然后重新执行操作命令，我们发现这种方式效率非常低。</p>
<p><code>gh-ost</code> 可以通过 unix socket 文件或者TCP端口（可配置）的方式来监听请求，操作者可以在命令运行后更改相应的参数，参考下面的例子：</p>
<ul>
<li><code>echo throttle | socat - /tmp/gh-ost.sock</code>  打开限速，同样的，可以使用 <code>no-throttle</code> 来关闭限流。</li>
<li>改变执行参数: <code>chunk-size=1500</code>, <code>max-lag-millis=2000</code>, <code>max-load=Thread_running=30</code> 这些参数都可以在运行时变更。</li>
</ul>
<h1 id="可审计"><a href="#可审计" class="headerlink" title="可审计"></a>可审计</h1><p>同样的，使用上文提到的程序接口可以获取 <code>gh-ost</code> 的状态。<code>gh-ost</code> 可以报告当前的进度，主要参数的配置以及当前服务器的标示等等。这些信息都可以通过网络接口取到，相对于传统的tail日志的方式要灵活很多。</p>
<h1 id="可测试"><a href="#可测试" class="headerlink" title="可测试"></a>可测试</h1><p>因为日志文件和主库负载关系不大，因此在从库上执行修改表结构的操作可以更真实的体现出这些操作锁产生的实际影响。(虽然不是十分理想，后续我们会做优化工作)。</p>
<p><code>gh-ost</code> 內建支持测试功能，通过使用 <code>--test-on-replica</code> 的参数来指定: 它可以在从库上进行变更操作，在操作结束时<code>gh-ost</code> 将会停止复制，交换表，反向交换表，保留2个表并保持同步，停止复制。可以在空闲时候测试和比较两个表的数据情况。</p>
<p>这是我们在GitHub的生产环境中的测试：我们生产环境中有多个从库；部分从库并不是为用户提供服务的，而是用来对所有表运行的连续覆盖迁移测试。我们生产环境中的表，小的可能没有数据，大的会达到数百GB，我们只是做个标记，并不会正在的修改表结构（engine=innodb）。当每一个迁移结束后会停止复制，我们会对原表和临时表的数据进行完整的checksum确保他们的数据一致性。然后我们会恢复复制，再去操作下一张表。我们的生产环境的从库中已经通过 gh-ost 成功的操作了很多表。</p>
<h1 id="值得信赖"><a href="#值得信赖" class="headerlink" title="值得信赖"></a>值得信赖</h1><p>上文提到说了这么多，都是为了提高大家对 <code>gh-ost</code> 的信任程度。毕竟在业界它还是一个新手，类似的工具已经存在了很多年了。</p>
<ul>
<li><p>在第一次试手之前我们建议用户先在从库上测试，校验数据的一致性。我们已经在从库上成功的进行了数以千计的迁移操作。</p>
</li>
<li><p>如果在主库上使用 <code>gh-ost</code> 用户可以实时观察主库的负载情况，如果发现负载变化很大，可以通过上文提到的多种形式进行限速，直到负载恢复正常，然后再通过命令微调参数，这样可以动态的控制操作风险。</p>
</li>
<li><p>如果迁移操作开始后预完成计时间（ETA）显示要到夜里2点才能完成，结束时候需要切换表，你是不是要留下来盯着？你可以通过标记文件让gh-ost推迟切换操作。gh-ost 会完成行复制，但并不会切换表，它会持续的将原表的数据更新操作同步到临时表中。你第二天来到办公室，删除标记文件或者通过接口 <code>echo unpostpone</code> 告诉gh-ost开始切换表。我们不想让我们的软件把使用者绑住，它应该是为我们拜托束缚。</p>
</li>
<li><p>说到 ETA, <code>--exact-rowcount</code> 参数你可能会喜欢。相对于一条漫长的 <code>SELECT COUNT(*)</code> 语句，gh-ost 会预估出迁移操作所需要花费的时间，还会根据当前迁移的工作状况更新预估时间。虽然ETA的时间随时更改，但进度百分比的显示是准确的。</p>
</li>
</ul>
<h1 id="gh-ost-操作模式"><a href="#gh-ost-操作模式" class="headerlink" title="gh-ost 操作模式"></a>gh-ost 操作模式</h1><p>gh-ost 可以同时连接多个服务器，为了获取二进制的数据流，它会作为一个从库，将数据从一个库复制到另外一个。它有各种不同的操作模式，这取决于你的设置，配置，和要运行迁移环境。</p>
<p><img src="/img/gh-ost3.png" alt="gh-ost3"></p>
<h2 id="a-连接到从库，在主库做迁移"><a href="#a-连接到从库，在主库做迁移" class="headerlink" title="a. 连接到从库，在主库做迁移"></a>a. 连接到从库，在主库做迁移</h2><p>这是  gh-ost 默认的工作方式。gh-ost 将会检查从库状态，找到集群结构中的主库并连接，接下来进行迁移操作：</p>
<ul>
<li>行数据在主库上读写</li>
<li>读取从库的二进制日志，将变更应用到主库</li>
<li>在从库收集表格式，字段&amp;索引，行数等信息</li>
<li>在从库上读取内部的变更事件（如心跳事件）</li>
<li>在主库切换表</li>
</ul>
<p>如果你的主库的日志格式是 SBR，工具也可以正常工作。但从库必须启用二级制日志(log_bin, log_slave_updates) 并且设置 <code>binlog_format=ROW</code> ( gh-ost 是读取从库的二级制文件)。</p>
<p>如果直接在主库上操作，当然也需要二进制日志格式是RBR。</p>
<h2 id="b-连接到主库"><a href="#b-连接到主库" class="headerlink" title="b. 连接到主库"></a>b. 连接到主库</h2><p>如果你没有从库，或者不想使用从库，你可以直接在主库上操作。<code>gh-ost</code> 将会直接在主库上进行所有操作。你需要持续关注复制延迟问题。</p>
<ul>
<li>你的主库的二进制日志必须是 RBR 格式。</li>
<li>在这个模式中你必须指定 <code>--allow-on-master</code> 参数</li>
</ul>
<h2 id="c-在从库迁移-测试"><a href="#c-在从库迁移-测试" class="headerlink" title="c. 在从库迁移/测试"></a>c. 在从库迁移/测试</h2><p>该模式会在从库执行迁移操作。gh-ost 会简单的连接到主库，此后所有的操作都在从库执行，不会对主库进行任何的改动。整个操作过程中，gh-ost 将控制速度保证从库可以及时的进行数据同步</p>
<ul>
<li><code>--migrate-on-replica</code> 表示 gh-ost 会直接在从库上进行迁移操作。即使在复制运行阶段也可以进行表的切换操作。</li>
<li><code>--test-on-replica</code> 表示 迁移操作只是为了测试在切换之前复制会停止，然后会进行切换操作，然后在切换回来，你的原始表最终还是原始表。两个表都会保存下来，复制操作是停止的。你可以对这两个表进行一致性检查等测试操作。</li>
</ul>
<h1 id="gh-ost-at-GitHub"><a href="#gh-ost-at-GitHub" class="headerlink" title="gh-ost at GitHub"></a>gh-ost at GitHub</h1><p>我们已经在所有线上所有的数据库在线操作中使用了gh-ost ，我们每天都需要使用它，根据数据库修改需求，可能每天要运行多次。凭借其审计和控制功能我们已经将它集成到了<a href="https://www.pagerduty.com/blog/what-is-chatops/" target="_blank" rel="noopener">ChatOps</a>流程中。我们的工程师可以清醒的了解到迁移操作的进度，而且可以灵活的控制其行为。</p>
<h1 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h1><p>gh-ost 在<a href="https://github.com/github/gh-ost/blob/master/LICENSE" target="_blank" rel="noopener">MIT的许可</a>下发布到了<a href="https://github.com/github/gh-ost" target="_blank" rel="noopener">开源社区</a>。</p>
<p>虽然gh-ost在使用中很稳定，我们还在不断的完善和改进。我们将其开源也欢迎社会各界的朋友能够参与和贡献。随后我们会发布 贡献和建议的页面。</p>
<p>我们会积极的维护 gh-ost 项目，同时希望广大的用户可以尝试和测试这个工具，我们做了很大努力使之更值得信赖。</p>
<h2 id="译者注"><a href="#译者注" class="headerlink" title="译者注"></a>译者注</h2><p>gh-ost 是MySQL业界在线修改表结构工具中的一名新秀，通常我们都是通过Percona的pt-online-schema-change工具来做这项工作，gh-ost的出现给我们带来了一种全新的方式。本文是翻译了一篇gh-ost的介绍文章，还没有尝试过这个工具。欢迎喜欢尝鲜网友谈谈使用感受。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL在线更改schema的工具很多，如Percona的&lt;a href=&quot;https://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="数据库工具" scheme="https://salogs.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MySQL" scheme="https://salogs.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>配置 salt</title>
    <link href="https://salogs.com/news/2015/08/20/configure-salt/"/>
    <id>https://salogs.com/news/2015/08/20/configure-salt/</id>
    <published>2015-08-20T09:31:26.000Z</published>
    <updated>2015-08-20T09:48:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>客户端配置比较简单，只需要配置一下server的地址就可以了，复杂的配置等到以后遇到的适合在进行介绍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置salt服务端地址</span></span><br><span class="line">vi /etc/salt/minion</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里也可以写主机名</span></span><br><span class="line">master: 192.168.1.100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改完成后重启服务</span></span><br><span class="line">service salt-minion restart</span><br></pre></td></tr></table></figure>
<h2 id="服务端操作"><a href="#服务端操作" class="headerlink" title="服务端操作"></a>服务端操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看有哪些client发起了验证请求 </span></span><br><span class="line">salt-key list</span><br><span class="line"></span><br><span class="line">Accepted Keys:</span><br><span class="line">Denied Keys:</span><br><span class="line">Unaccepted Keys:  <span class="comment"># 这里列出了为被接受的client 主机名</span></span><br><span class="line">host01</span><br><span class="line">host02</span><br><span class="line">Rejected Keys:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受所有验证请求</span></span><br><span class="line">salt-key -A</span><br><span class="line">The following keys are going to be accepted:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">host01</span><br><span class="line">host02</span><br><span class="line">Proceed? [n/Y] Y</span><br><span class="line">Key <span class="keyword">for</span> minion host01 accepted.</span><br><span class="line">Key <span class="keyword">for</span> minion host02 accepted.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再查看一下</span></span><br><span class="line">salt-key list</span><br><span class="line">Accepted Keys:  <span class="comment"># 已经接受</span></span><br><span class="line">host01</span><br><span class="line">host02</span><br><span class="line">Denied Keys:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">Rejected Keys:</span><br></pre></td></tr></table></figure>
<h1 id="简单验证执行命令"><a href="#简单验证执行命令" class="headerlink" title="简单验证执行命令"></a>简单验证执行命令</h1><h2 id="远程执行命令"><a href="#远程执行命令" class="headerlink" title="远程执行命令"></a>远程执行命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">salt aws-bj* cmd.run uptime</span><br><span class="line">host01:</span><br><span class="line">     09:42:13 up  2:02,  2 users,  load average: 0.05, 0.03, 0.05</span><br><span class="line">host02:</span><br><span class="line">     09:42:12 up  1:28,  1 user,  load average: 0.00, 0.01, 0.05</span><br></pre></td></tr></table></figure>
<h1 id="下篇预告"><a href="#下篇预告" class="headerlink" title="下篇预告"></a>下篇预告</h1><ul>
<li><a href="http://salogs.com/news/2015/08/20/group-salt/">03. 将client主机分组</a></li>
</ul>
<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ul>
<li><a href="http://salogs.com/news/2015/08/20/ubuntu-install-salt/">01. Ubuntu 安装salt</a></li>
<li><a href="http://salogs.com/news/2015/08/20/configure-salt/">02. 配置 salt</a></li>
<li><a href="http://salogs.com/news/2015/08/20/group-salt/">03. 将client主机分组</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;h2 id=&quot;客户端配置&quot;&gt;&lt;a href=&quot;#客户端配置&quot; class=&quot;headerlink&quot; title=&quot;客户端配置&quot;&gt;&lt;/a&gt;客户端配
    
    </summary>
    
      <category term="运维自动化" scheme="https://salogs.com/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="salt" scheme="https://salogs.com/tags/salt/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装salt</title>
    <link href="https://salogs.com/news/2015/08/20/ubuntu-install-salt/"/>
    <id>https://salogs.com/news/2015/08/20/ubuntu-install-salt/</id>
    <published>2015-08-20T09:10:26.000Z</published>
    <updated>2016-07-19T10:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h1><p>最新的salt包会发布在 Ubuntu saltstack PPA。如果你的系统中有<code>add-apt-repository</code> 工具，可以通过一条命令添加仓库并导入PPA key：</p>
<h2 id="通过add-apt-repository添加仓库及PPA-key"><a href="#通过add-apt-repository添加仓库及PPA-key" class="headerlink" title="通过add-apt-repository添加仓库及PPA key"></a>通过add-apt-repository添加仓库及PPA key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-apt-repository ppa:saltstack/salt</span><br><span class="line"></span><br><span class="line"> Salt, the remote execution and configuration management tool.</span><br><span class="line"> More info: https://launchpad.net/~saltstack/+archive/ubuntu/salt</span><br><span class="line">Press [ENTER] to <span class="built_in">continue</span> or ctrl-c to cancel adding it</span><br><span class="line"></span><br><span class="line">gpg: keyring `/tmp/tmpys0ah_nb/secring.gpg<span class="string">' created</span></span><br><span class="line"><span class="string">gpg: keyring `/tmp/tmpys0ah_nb/pubring.gpg'</span> created</span><br><span class="line">gpg: requesting key 0E27C0A6 from hkp server keyserver.ubuntu.com</span><br><span class="line">gpg: /tmp/tmpys0ah_nb/trustdb.gpg: trustdb created</span><br><span class="line">gpg: key 0E27C0A6: public key <span class="string">"Launchpad PPA for Salt Stack"</span> imported</span><br><span class="line">gpg: Total number processed: 1</span><br><span class="line">gpg:               imported: 1  (RSA: 1)</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果没有找到add-apt-repository命令可以执行下面的命令进行安装</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python-software-properties</span><br></pre></td></tr></table></figure>
<p>可能也需要安装下面的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install software-properties-common</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="手动添加仓库及PPA-key"><a href="#手动添加仓库及PPA-key" class="headerlink" title="手动添加仓库及PPA  key"></a>手动添加仓库及PPA  key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> deb http://ppa.launchpad.net/saltstack/salt/ubuntu `lsb_release -sc` main | sudo tee /etc/apt/sources.list.d/saltstack.list</span><br><span class="line">wget -q -O- <span class="string">"http://keyserver.ubuntu.com:11371/pks/lookup?op=get&amp;search=0x4759FA960E27C0A6"</span> |apt-key add -</span><br></pre></td></tr></table></figure>
<h2 id="更新仓库元数据"><a href="#更新仓库元数据" class="headerlink" title="更新仓库元数据"></a>更新仓库元数据</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>
<h1 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install salt-master salt-minion salt-syndic</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install salt-minion</span><br></pre></td></tr></table></figure>
<h1 id="ZEROMQ-4"><a href="#ZEROMQ-4" class="headerlink" title="ZEROMQ 4"></a>ZEROMQ 4</h1><p>ZeroMQ 4 在 Ubuntu 14.04 以上版本已经与系统集成。因此Ubuntu 12.04 LTS 之前的版本需要升级到ZEROMQ 4</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;添加仓库&quot;&gt;&lt;a href=&quot;#添加仓库&quot; class=&quot;headerlink&quot; title=&quot;添加仓库&quot;&gt;&lt;/a&gt;添加仓库&lt;/h1&gt;&lt;p&gt;最新的salt包会发布在 Ubuntu saltstack PPA。如果你的系统中有&lt;code&gt;add-apt-reposi
    
    </summary>
    
      <category term="运维自动化" scheme="https://salogs.com/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="salt" scheme="https://salogs.com/tags/salt/"/>
    
  </entry>
  
  <entry>
    <title>保存iptable规则并开机自动加载</title>
    <link href="https://salogs.com/news/2015/08/20/iptables-save/"/>
    <id>https://salogs.com/news/2015/08/20/iptables-save/</id>
    <published>2015-08-20T08:46:27.000Z</published>
    <updated>2015-08-20T09:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iptables-save"><a href="#iptables-save" class="headerlink" title="iptables-save"></a>iptables-save</h1><p>利用iptables-save命令可以将iptable规则保存到一个持久化存储的目录中，不同的系统保存的目录也有所不同（IPv4）：</p>
<p>Debian/Ubuntu: <code>iptables-save</code> &gt; /etc/iptables/rules.v4</p>
<p>RHEL/CentOS: <code>iptables-save</code> &gt; /etc/sysconfig/iptables</p>
<p>保存之后，可以通过iptables-restore命令载入（IPv4）：</p>
<p>Debian/Ubuntu: <code>iptables-restore</code> &lt; /etc/iptables/rules.v4</p>
<p>RHEL/CentOS: <code>iptables-restore</code> &lt; /etc/sysconfig/iptables</p>
<p>上面是针对IPv5的规则，如果你有使用IPv6的规则，通常需要执行下面对应的IPv6保存和恢复的命令（IPv4：</p>
<p>Debian/Ubuntu: <code>ip6tables-save</code> &gt; /etc/iptables/rules.v6<br>RHEL/CentOS: <code>ip6tables-save</code> &gt; /etc/sysconfig/ip6tables</p>
<p><strong>注意：</strong> 这种方式只是保存规则和恢复的一种方式，并不是说保存规则后下次启动就会自动加载。一定要记住这点，如果要想系统启动后自动加载请看下面的方式。</p>
<h1 id="iptables-persistent-Debian-Ubuntu"><a href="#iptables-persistent-Debian-Ubuntu" class="headerlink" title="iptables-persistent (Debian/Ubuntu)"></a>iptables-persistent (Debian/Ubuntu)</h1><p>从 Ubuntu 10.04 LTS (Lucid) 和 Debian 6.0 (Squeeze) 版本开始，可以通过安装一个名为 “iptables-persistent” 的包，安装后它以守护进程的方式来运行，系统重启后可以自动将保存的内容加载到iptables中。当然前提也是需要先保存规则。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install iptables-persistent</span><br></pre></td></tr></table></figure>
<h2 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service  iptables-persistent save</span><br><span class="line">* Saving rules...                                                                                                                                                                 *  IPv4...                                                                                                                                                                        *  IPv6...</span><br><span class="line"></span><br><span class="line">ls -1 /etc/iptables/</span><br><span class="line">rules.v4</span><br><span class="line">rules.v6</span><br><span class="line"></span><br><span class="line">cat  /etc/iptables/rules.v4</span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.21 on Thu Aug 20 08:59:52 2015</span></span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [5726:774869]</span><br><span class="line">:FORWARD ACCEPT [170:27598]</span><br><span class="line">:OUTPUT ACCEPT [5467:789045]</span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Thu Aug 20 08:59:52 2015</span></span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.21 on Thu Aug 20 08:59:52 2015</span></span><br><span class="line">*nat</span><br><span class="line">:PREROUTING ACCEPT [23:1596]</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [9:540]</span><br><span class="line">:POSTROUTING ACCEPT [0:0]</span><br><span class="line">-A POSTROUTING <span class="_">-s</span> 10.0.0.0/16 -o eth0 -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Thu Aug 20 08:59:52 2015</span></span><br></pre></td></tr></table></figure>
<h1 id="RHEL-和-CentOS-保存规则"><a href="#RHEL-和-CentOS-保存规则" class="headerlink" title="RHEL 和 CentOS 保存规则"></a>RHEL 和 CentOS 保存规则</h1><p>RHEL/CentOS 提供了简单的方式来持久化存储iptables规则，可以直接通过iptables服务的命令来完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig --list | grep iptables</span><br><span class="line">  iptables       	0:off	1:off	2:on	3:on	4:on	5:on	6:off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不是开机启动，需要执行下面命令</span></span><br><span class="line">chkconfig iptables on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>
<p>IPv4规则信息会保存到 /etc/sysconfig/iptables 文件中，IPv6 规则保存到 /etc/sysconfig/ip6tables 文件中。 必须执行<code>service iptables save</code> 命令才会保存，保存后系统重启后会自动加载。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iptables-save&quot;&gt;&lt;a href=&quot;#iptables-save&quot; class=&quot;headerlink&quot; title=&quot;iptables-save&quot;&gt;&lt;/a&gt;iptables-save&lt;/h1&gt;&lt;p&gt;利用iptables-save命令可以将iptabl
    
    </summary>
    
      <category term="经验分享" scheme="https://salogs.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
      <category term="Iptables" scheme="https://salogs.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/Iptables/"/>
    
    
      <category term="iptables" scheme="https://salogs.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>MySQL备份与恢复</title>
    <link href="https://salogs.com/news/2015/08/17/database-backup-and-recovery/"/>
    <id>https://salogs.com/news/2015/08/17/database-backup-and-recovery/</id>
    <published>2015-08-17T06:04:14.000Z</published>
    <updated>2015-08-17T06:06:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h1><h2 id="当前数据库结构"><a href="#当前数据库结构" class="headerlink" title="当前数据库结构"></a>当前数据库结构</h2><p>db01 （主）</p>
<p>db02 （从）</p>
<h2 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h2><ul>
<li>每天一次全量备份</li>
<li>每小时一次增量备份</li>
<li>通过热备工具（不锁表，不影响线上应用）备份主库数据</li>
<li>备份数据保存到db01，备份完成scp到db02</li>
<li>保留一个月的增量及全量备份</li>
</ul>
<table>
<thead>
<tr>
<th>时间</th>
<th>备份类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>00:01</td>
<td>全量备份</td>
</tr>
<tr>
<td>01:01</td>
<td>增量备份(当天首次)</td>
</tr>
<tr>
<td>02:01~23:01</td>
<td>增量备份</td>
</tr>
</tbody>
</table>
<blockquote>
<p>随着数据量的增加，全量备份可以做成每周一次，每2~8小时一次增量备份</p>
</blockquote>
<h2 id="备份目录"><a href="#备份目录" class="headerlink" title="备份目录"></a>备份目录</h2><p>db{01,02}:/data/backup/{full,incremental}/</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backup/</span><br><span class="line">├── full</span><br><span class="line">│   ├── 2015-08-16       <span class="comment"># 每日全量备份</span></span><br><span class="line">│   └── 2015-08-16.log   <span class="comment"># 全量备份日志</span></span><br><span class="line">└── incremental </span><br><span class="line">    ├── 2015-08-16_14        <span class="comment"># 每小时增量备份</span></span><br><span class="line">    ├── 2015-08-16_14.log    <span class="comment"># 每小时增量备份日志</span></span><br><span class="line">    ├── 2015-08-16_15</span><br><span class="line">    ├── 2015-08-16_15.log</span><br><span class="line">    ├── 2015-08-16_16</span><br><span class="line">    ├── 2015-08-16_16.log</span><br><span class="line">    ├── 2015-08-16_17</span><br><span class="line">    ├── 2015-08-16_17.log</span><br><span class="line">    ├── 2015-08-16_18</span><br><span class="line">    ├── 2015-08-16_18.log</span><br><span class="line">    ├── 2015-08-16_19</span><br><span class="line">    └── 2015-08-16_19.log</span><br></pre></td></tr></table></figure>
<h2 id="备份计划任务"><a href="#备份计划任务" class="headerlink" title="备份计划任务"></a>备份计划任务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Info   : 数据库备份</span></span><br><span class="line"><span class="comment"># Author : zhouyq</span></span><br><span class="line"><span class="comment"># CTime  : 2015-08-16</span></span><br><span class="line"><span class="comment"># 全量备份</span></span><br><span class="line">1 0 * * *     /bin/bash /root/bin/bakdb.sh full</span><br><span class="line"><span class="comment"># 第一次增量备份</span></span><br><span class="line">1 1 * * *     /bin/bash /root/bin/bakdb.sh incremental first</span><br><span class="line"><span class="comment"># 其他时间段增量备份</span></span><br><span class="line">1 2-23 * * *  /bin/bash /root/bin/bakdb.sh incremental</span><br></pre></td></tr></table></figure>
<h2 id="备份脚本"><a href="#备份脚本" class="headerlink" title="备份脚本"></a>备份脚本</h2><p>/root/bin/bakdb.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">fullPath=<span class="string">"/data/backup/full"</span></span><br><span class="line">incrPath=<span class="string">"/data/backup/incremental"</span></span><br><span class="line">bakdate=`date +<span class="string">'%F'</span>`</span><br><span class="line">bakhour=`date +<span class="string">'%H'</span>`</span><br><span class="line"></span><br><span class="line">oneHourAgo=`date <span class="_">-d</span> <span class="string">'1 hours ago'</span> +<span class="string">'%F_%H'</span>`</span><br><span class="line"></span><br><span class="line">BakB<span class="keyword">in</span>=<span class="string">"/usr/bin/innobackupex --no-timestamp --user=root --socket /data/db/tmp/mysql.sock  --defaults-file=/usr/local/mysql/my.cnf --sleep 100"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># backup function</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hotbackup</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  baktype=<span class="variable">$1</span></span><br><span class="line">  logfile=<span class="variable">$2</span></span><br><span class="line">  incrpath=<span class="variable">$3</span></span><br><span class="line">  bakpath=<span class="variable">$4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$baktype</span>"</span> == <span class="string">"full"</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="variable">$BakBin</span>  <span class="variable">$bakpath</span>   &gt; <span class="variable">$logfile</span> 2&gt;&amp;1</span><br><span class="line">  <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$baktype</span>"</span> == <span class="string">"incremental"</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="variable">$BakBin</span> --incremental <span class="variable">$incrpath</span> --incremental-basedir <span class="variable">$bakpath</span> &gt; <span class="variable">$logfile</span> 2&gt;&amp;1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ============= Main =============</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"full"</span> ];<span class="keyword">then</span></span><br><span class="line">   <span class="comment"># 全量备份</span></span><br><span class="line">   hotbackup <span class="string">"full"</span> <span class="string">"<span class="variable">$&#123;fullPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>.log"</span> <span class="string">"none"</span> <span class="string">"<span class="variable">$fullPath</span>/<span class="variable">$bakdate</span>"</span></span><br><span class="line">   /usr/bin/scp -P 9922 -rp  <span class="variable">$&#123;fullPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>* db02:<span class="variable">$&#123;fullPath&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$1</span>"</span> == <span class="string">"incremental"</span> ];<span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 判断是否为第一次增量备份，只有第一次增量备份目录指向全量备份</span></span><br><span class="line">  <span class="comment"># 第二次开始增量备份的上一次目录指向第一次增量目录即可</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$2</span>"</span> == <span class="string">"first"</span> ];<span class="keyword">then</span></span><br><span class="line">     hotbackup <span class="string">"incremental"</span> <span class="string">"<span class="variable">$&#123;incrPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>.log"</span> <span class="string">"<span class="variable">$incrPath</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>"</span> <span class="string">"<span class="variable">$fullPath</span>/<span class="variable">$bakdate</span>"</span></span><br><span class="line">     /usr/bin/scp -P 9922 -rp <span class="variable">$&#123;incrPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>* db02:<span class="variable">$&#123;incrPath&#125;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     hotbackup <span class="string">"incremental"</span> <span class="string">"<span class="variable">$&#123;incrPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>.log"</span> <span class="string">"<span class="variable">$incrPath</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>"</span> <span class="string">"<span class="variable">$incrPath</span>/<span class="variable">$&#123;oneHourAgo&#125;</span>"</span></span><br><span class="line">     /usr/bin/scp -P 9922 -rp <span class="variable">$&#123;incrPath&#125;</span>/<span class="variable">$&#123;bakdate&#125;</span>_<span class="variable">$&#123;bakhour&#125;</span>* db02:<span class="variable">$&#123;incrPath&#125;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><h3 id="全量备份恢复"><a href="#全量备份恢复" class="headerlink" title="全量备份恢复"></a>全量备份恢复</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innobackupex --user=root --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --apply-log /data/backup/full/2015-08-16</span><br><span class="line"></span><br><span class="line">innobackupex --user=root --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --move-back /data/backup/full/2015-08-16</span><br></pre></td></tr></table></figure>
<h3 id="增量备份恢复"><a href="#增量备份恢复" class="headerlink" title="增量备份恢复"></a>增量备份恢复</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">innobackupex --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --user=root --apply-log --redo-only /data/backup/full/2015-08-16 </span><br><span class="line">  </span><br><span class="line">innobackupex --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --user=root --apply-log --redo-only /data/backup/full/2015-08-16 --incremental-dir=/data/backup/incremental/2015-08-16_14  </span><br><span class="line">  </span><br><span class="line">innobackupex --defaults-file=/usr/<span class="built_in">local</span>/mysql/my.cnf --user=root --apply-log --redo-only /data/backup/full/2015-08-16 --incremental-dir=/data/backup/incremental/2015-08-16_15</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库备份与恢复&quot;&gt;&lt;a href=&quot;#数据库备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;数据库备份与恢复&quot;&gt;&lt;/a&gt;数据库备份与恢复&lt;/h1&gt;&lt;h2 id=&quot;当前数据库结构&quot;&gt;&lt;a href=&quot;#当前数据库结构&quot; class=&quot;header
    
    </summary>
    
      <category term="经验分享" scheme="https://salogs.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
      <category term="MySQL" scheme="https://salogs.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/MySQL/"/>
    
    
      <category term="XtraBackup" scheme="https://salogs.com/tags/XtraBackup/"/>
    
  </entry>
  
  <entry>
    <title>【转】十条有用的 GO 技术</title>
    <link href="https://salogs.com/news/2015/08/04/ten-go-best-practice/"/>
    <id>https://salogs.com/news/2015/08/04/ten-go-best-practice/</id>
    <published>2015-08-04T01:16:16.000Z</published>
    <updated>2015-08-04T03:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文<a href="http://mikespook.com/2014/07/%e5%8d%81%e6%9d%a1%e6%9c%89%e7%94%a8%e7%9a%84-go-%e6%8a%80%e6%9c%af/" target="_blank" rel="noopener">在此</a>，实用总结。</p>
<hr>
<h1 id="十条有用的-Go-技术"><a href="#十条有用的-Go-技术" class="headerlink" title="十条有用的 Go 技术"></a>十条有用的 Go 技术</h1><p>这里是我过去几年中编写的大量 Go 代码的经验总结而来的自己的最佳实践。我相信它们具有弹性的。这里的弹性是指：<br>某个应用需要适配一个灵活的环境。你不希望每过 3 到 4 个月就不得不将它们全部重构一遍。添加新的特性应当很容易。许多人参与开发该应用，它应当可以被理解，且维护简单。许多人使用该应用，bug 应该容易被发现并且可以快速的修复。我用了很长的时间学到了这些事情。其中的一些很微小，但对于许多事情都会有影响。所有这些都仅仅是建议，具体情况具体对待，并且如果有帮助的话务必告诉我。随时留言:)</p>
<h1 id="1-使用单一的-GOPATH"><a href="#1-使用单一的-GOPATH" class="headerlink" title="1. 使用单一的 GOPATH"></a>1. 使用单一的 GOPATH</h1><p>多个 GOPATH 的情况并不具有弹性。GOPATH 本身就是高度自我完备的（通过导入路径）。有多个 GOPATH 会导致某些副作用，例如可能使用了给定的库的不同的版本。你可能在某个地方升级了它，但是其他地方却没有升级。而且，我还没遇到过任何一个需要使用多个 GOPATH 的情况。所以只使用单一的 GOPATH，这会提升你 Go 的开发进度。</p>
<p>许多人不同意这一观点，接下来我会做一些澄清。像 <a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">etcd</a> 或 <a href="https://camlistore.org/" target="_blank" rel="noopener">camlistore</a> 这样的大项目使用了像 <a href="https://github.com/tools/godep" target="_blank" rel="noopener">godep</a> 这样的工具，将所有依赖保存到某个目录中。也就是说，这些项目自身有一个单一的 GOPATH。它们只能在这个目录里找到对应的版本。除非你的项目很大并且极为重要，否则不要为每个项目使用不同的 GOPATH。如果你认为项目需要一个自己的 GOPATH 目录，那么就创建它，否则不要尝试使用多个 GOPATH。它只会拖慢你的进度。</p>
<h1 id="2-将-for-select-封装到函数中"><a href="#2-将-for-select-封装到函数中" class="headerlink" title="2. 将 for-select 封装到函数中"></a>2. 将 for-select 封装到函数中</h1><p>如果在某个条件下，你需要从 for-select 中退出，就需要使用标签。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">L:</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span> L</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fmt.Println(<span class="string">"ending"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，需要联合break使用标签。这有其用途，不过我不喜欢。这个例子中的 for 循环看起来很小，但是通常它们会更大，而判断break的条件也更为冗长。</p>
<p>如果需要退出循环，我会将 for-select 封装到函数中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">    fmt.Println(<span class="string">"ending"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">            fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以返回一个错误（或任何其他值），也是同样漂亮的，只需要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 阻塞</span><br><span class="line"><span class="keyword">if</span> err := foo(); err != nil &#123;</span><br><span class="line">    // 处理 err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-在初始化结构体时使用带有标签的语法"><a href="#3-在初始化结构体时使用带有标签的语法" class="headerlink" title="3. 在初始化结构体时使用带有标签的语法"></a>3. 在初始化结构体时使用带有标签的语法</h1><p>这是一个无标签语法的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    Foo <span class="keyword">string</span></span><br><span class="line">    Bar <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;<span class="string">"example"</span>, <span class="number">123</span>&#125; <span class="comment">// 无标签语法</span></span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果你添加一个新的字段到T结构体，代码会编译失败：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    Foo <span class="keyword">string</span></span><br><span class="line">    Bar <span class="keyword">int</span></span><br><span class="line">    Qux <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;<span class="string">"example"</span>, <span class="number">123</span>&#125; <span class="comment">// 无法编译</span></span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用了标签语法，Go 的兼容性规则（<a href="http://golang.org/doc/go1compat" target="_blank" rel="noopener">http://golang.org/doc/go1compat</a>）会处理代码。例如在向net包的类型添加叫做Zone的字段，参见：<a href="http://golang.org/doc/go1.1#library" target="_blank" rel="noopener">http://golang.org/doc/go1.1#library</a>。回到我们的例子，使用标签语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> T struct &#123;</span><br><span class="line">    Foo string</span><br><span class="line">    Bar int</span><br><span class="line">    Qux string</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    t := T&#123;Foo: <span class="string">"example"</span>, Qux: 123&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个编译起来没问题，而且弹性也好。不论你如何添加其他字段到T结构体。你的代码总是能编译，并且在以后的 Go 的版本也可以保证这一点。只要在代码集中执行go vet，就可以发现所有的无标签的语法。</p>
<h1 id="4-将结构体的初始化拆分到多行"><a href="#4-将结构体的初始化拆分到多行" class="headerlink" title="4. 将结构体的初始化拆分到多行"></a>4. 将结构体的初始化拆分到多行</h1><p>如果有两个以上的字段，那么就用多行。它会让你的代码更加容易阅读，也就是说不要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">T&#123;Foo: <span class="string">"example"</span>, Bar:someLongVariable, Qux:anotherLongVariable, B: forgetToAddThisToo&#125;</span><br></pre></td></tr></table></figure>
<p>而是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">T&#123;</span><br><span class="line">    Foo: <span class="string">"example"</span>,</span><br><span class="line">    Bar: someLongVariable,</span><br><span class="line">    Qux: anotherLongVariable,</span><br><span class="line">    B: forgetToAddThisToo,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有许多好处，首先它容易阅读，其次它使得允许或屏蔽字段初始化变得容易（只要注释或删除它们），最后添加其他字段也更容易（只要添加一行）。</p>
<h1 id="5-为整数常量添加-String-方法"><a href="#5-为整数常量添加-String-方法" class="headerlink" title="5. 为整数常量添加 String() 方法"></a>5. 为整数常量添加 String() 方法</h1><p>如果你利用 iota 来使用自定义的整数枚举类型，务必要为其添加 String() 方法。例如，像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="keyword">int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Running State = <span class="literal">iota</span></span><br><span class="line">    Stopped</span><br><span class="line">    Rebooting</span><br><span class="line">    Terminated</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果你创建了这个类型的一个变量，然后输出，会得到一个整数（<a href="http://play.golang.org/p/V5VVFB05HB" target="_blank" rel="noopener">http://play.golang.org/p/V5VVFB05HB</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    state := Running</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// print: "state 0"</span></span><br><span class="line">    fmt.Println(<span class="string">"state "</span>, state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非你回顾常量定义，否则这里的0看起来毫无意义。只需要为State类型添加String()方法就可以修复这个问题（<a href="http://play.golang.org/p/ewMKl6K302" target="_blank" rel="noopener">http://play.golang.org/p/ewMKl6K302</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s State)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> s &#123;</span><br><span class="line">    <span class="keyword">case</span> Running:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Running"</span></span><br><span class="line">    <span class="keyword">case</span> Stopped:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stopped"</span></span><br><span class="line">    <span class="keyword">case</span> Rebooting:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Rebooting"</span></span><br><span class="line">    <span class="keyword">case</span> Terminated:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Terminated"</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Unknown"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的输出是：state: Running。显然现在看起来可读性好了很多。在你调试程序的时候，这会带来更多的便利。同时还可以在实现 MarshalJSON()、UnmarshalJSON() 这类方法的时候使用同样的手段。</p>
<h1 id="6-让-iota-从-a-1-开始增量"><a href="#6-让-iota-从-a-1-开始增量" class="headerlink" title="6. 让 iota 从 a +1 开始增量"></a>6. 让 iota 从 a +1 开始增量</h1><p>在前面的例子中同时也产生了一个我已经遇到过许多次的 bug。假设你有一个新的结构体，有一个State字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span></span><br><span class="line">    Port  <span class="keyword">int</span></span><br><span class="line">    State State</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在如果基于 T 创建一个新的变量，然后输出，你会得到奇怪的结果（<a href="http://play.golang.org/p/LPG2RF3y39" target="_blank" rel="noopener">http://play.golang.org/p/LPG2RF3y39</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;Name: <span class="string">"example"</span>, Port: <span class="number">6666</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// prints: "t &#123;Name:example Port:6666 State:Running&#125;"</span></span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到 bug 了吗？State字段没有初始化，Go 默认使用对应类型的零值进行填充。由于State是一个整数，零值也就是0，但在我们的例子中它表示Running。</p>
<p>那么如何知道 State 被初始化了？还是它真得是在Running模式？没有办法区分它们，那么这就会产生未知的、不可预测的 bug。不过，修复这个很容易，只要让 iota 从 +1 开始（<a href="http://play.golang.org/p/VyAq-3OItv" target="_blank" rel="noopener">http://play.golang.org/p/VyAq-3OItv</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Running State = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">    Stopped</span><br><span class="line">    Rebooting</span><br><span class="line">    Terminated</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>现在t变量将默认输出Unknown，不是吗？ :) </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;Name: <span class="string">"example"</span>, Port: <span class="number">6666</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出： "t &#123;Name:example Port:6666 State:Unknown&#125;"</span></span><br><span class="line">    fmt.Printf(<span class="string">"t %+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过让 iota 从零值开始也是一种解决办法。例如，你可以引入一个新的状态叫做Unknown，将其修改为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown State = <span class="literal">iota</span></span><br><span class="line">    Running</span><br><span class="line">    Stopped</span><br><span class="line">    Rebooting</span><br><span class="line">    Terminated</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="7-返回函数调用"><a href="#7-返回函数调用" class="headerlink" title="7. 返回函数调用"></a>7. 返回函数调用</h1><p>我已经看过很多代码例如（<a href="http://play.golang.org/p/8Rz1EJwFTZ" target="_blank" rel="noopener">http://play.golang.org/p/8Rz1EJwFTZ</a>）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    v, err := foo()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，你只需要：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更简单也更容易阅读（当然，除非你要对某些内部的值做一些记录）。</p>
<h1 id="8-把-slice、map-等定义为自定义类型"><a href="#8-把-slice、map-等定义为自定义类型" class="headerlink" title="8. 把 slice、map 等定义为自定义类型"></a>8. 把 slice、map 等定义为自定义类型</h1><p>将 slice 或 map 定义成自定义类型可以让代码维护起来更加容易。假设有一个Server类型和一个返回服务器列表的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListServers</span><span class="params">()</span> []<span class="title">Server</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []Server&#123;</span><br><span class="line">        &#123;Name: <span class="string">"Server1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Server2"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo2"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在假设需要获取某些特定名字的服务器。需要对 ListServers() 做一些改动，增加筛选条件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListServers 返回服务器列表。只会返回包含 name 的服务器。空的 name 将会返回所有服务器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListServers</span><span class="params">(name <span class="keyword">string</span>)</span> []<span class="title">Server</span></span> &#123;</span><br><span class="line">    servers := []Server&#123;</span><br><span class="line">        &#123;Name: <span class="string">"Server1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Server2"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo2"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回所有服务器</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> servers</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回过滤后的结果</span></span><br><span class="line">    filtered := <span class="built_in">make</span>([]Server, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, server := <span class="keyword">range</span> servers &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(server.Name, name) &#123;</span><br><span class="line">            filtered = <span class="built_in">append</span>(filtered, server)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以用这个来筛选有字符串Foo的服务器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    servers := ListServers(<span class="string">"Foo"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 输出：“servers [&#123;Name:Foo1&#125; &#123;Name:Foo2&#125;]”</span></span><br><span class="line">    fmt.Printf(<span class="string">"servers %+v\n"</span>, servers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然这个函数能够正常工作。不过它的弹性并不好。如果你想对服务器集合引入其他逻辑的话会如何呢？例如检查所有服务器的状态，为每个服务器创建一个数据库记录，用其他字段进行筛选等等……</p>
<p>现在引入一个叫做Servers的新类型，并且修改原始版本的 ListServers() 返回这个新类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Servers []Server</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ListServers 返回服务器列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListServers</span><span class="params">()</span> <span class="title">Servers</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []Server&#123;</span><br><span class="line">        &#123;Name: <span class="string">"Server1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Server2"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo1"</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">"Foo2"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在需要做的是只要为Servers类型添加一个新的Filter()方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Filter 返回包含 name 的服务器。空的 name 将会返回所有服务器。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Servers)</span> <span class="title">Filter</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Servers</span></span> &#123;</span><br><span class="line">    filtered := <span class="built_in">make</span>(Servers, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, server := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(server.Name, name) &#123;</span><br><span class="line">            filtered = <span class="built_in">append</span>(filtered, server)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以针对字符串Foo筛选服务器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    servers := ListServers()</span><br><span class="line">    servers = servers.Filter(<span class="string">"Foo"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"servers %+v\n"</span>, servers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈！看到你的代码是多么的简单了吗？还想对服务器的状态进行检查？或者为每个服务器添加一条数据库记录？没问题，添加以下新方法即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Servers)</span> <span class="title">Check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(s Servers)</span> <span class="title">AddRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(s Servers)</span> <span class="title">Len</span><span class="params">()</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>
<h1 id="9-withContext-封装函数"><a href="#9-withContext-封装函数" class="headerlink" title="9. withContext 封装函数"></a>9. withContext 封装函数</h1><p>有时对于函数会有一些重复劳动，例如锁/解锁，初始化一个新的局部上下文，准备初始化变量等等……这里有一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// foo 相关的工作</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// bar 相关的工作</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qux</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// qux 相关的工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想要修改某个内容，你需要对所有的都进行修改。如果它是一个常见的任务，那么最好创建一个叫做withContext的函数。这个函数的输入参数是另一个函数，并用调用者提供的上下文来调用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withLockContext</span><span class="params">(fn <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    mu.Lock</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"> </span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要将之前的函数用这个进行封装：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withLockContext(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// foo 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withLockContext(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// bar 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qux</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withLockContext(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// qux 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要光想着加锁的情形。对此来说最好的用例是数据库链接。现在对 withContext 函数作一些小小的改动：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withDBContext</span><span class="params">(fn <span class="keyword">func</span>(db DB)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从连接池获取一个数据库连接</span></span><br><span class="line">    dbConn := NewDB()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> fn(dbConn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，它获取一个连接，然后传递给提供的参数，并且在调用函数的时候返回错误。你需要做的只是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withDBContext(<span class="function"><span class="keyword">func</span><span class="params">(db *DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="comment">// foo 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withDBContext(<span class="function"><span class="keyword">func</span><span class="params">(db *DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="comment">// bar 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qux</span><span class="params">()</span></span> &#123;</span><br><span class="line">    withDBContext(<span class="function"><span class="keyword">func</span><span class="params">(db *DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="comment">// qux 相关工作</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你在考虑一个不同的场景，例如作一些预初始化？没问题，只需要将它们加到withDBContext就可以了。这对于测试也同样有效。</p>
<p>这个方法有个缺陷，它增加了缩进并且更难阅读。再次提示，永远寻找最简单的解决方案。</p>
<h1 id="10-为访问-map-增加-setter，getters"><a href="#10-为访问-map-增加-setter，getters" class="headerlink" title="10. 为访问 map 增加 setter，getters"></a>10. 为访问 map 增加 setter，getters</h1><p>如果你重度使用 map 读写数据，那么就为其添加 getter 和 setter 吧。通过 getter 和 setter 你可以将逻辑封分别装到函数里。这里最常见的错误就是并发访问。如果你在某个 goroutein 里有这样的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m[<span class="string">"foo"</span>] = bar</span><br></pre></td></tr></table></figure>
<p>还有这个：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, <span class="string">"foo"</span>)</span><br></pre></td></tr></table></figure>
<p>会发生什么？你们中的大多数应当已经非常熟悉这样的竞态了。简单来说这个竞态是由于 map 默认并非线程安全。不过你可以用互斥量来保护它们：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mu.Lock()</span><br><span class="line">m[<span class="string">"foo"</span>] = <span class="string">"bar"</span></span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mu.Lock()</span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"foo"</span>)</span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>假设你在其他地方也使用这个 map。你必须把互斥量放得到处都是！然而通过 getter 和 setter 函数就可以很容易的避免这个问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Put</span><span class="params">(key, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    m[key] = value</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(m, key)</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用接口可以对这一过程做进一步的改进。你可以将实现完全隐藏起来。只使用一个简单的、设计良好的接口，然后让包的用户使用它们：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">    Delete(key <span class="keyword">string</span>)</span><br><span class="line">    Get(key <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">    Put(key, value <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是个例子，不过你应该能体会到。对于底层的实现使用什么都没关系。不光是使用接口本身很简单，而且还解决了暴露内部数据结构带来的大量的问题。</p>
<p>但是得承认，有时只是为了同时对若干个变量加锁就使用接口会有些过分。理解你的程序，并且在你需要的时候使用这些改进。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>抽象永远都不是容易的事情。有时，最简单的就是你已经实现的方法。要知道，不要让你的代码看起来很聪明。Go 天生就是个简单的语言，在大多数情况下只会有一种方法来作某事。简单是力量的源泉，也是为什么在人的层面它表现的如此有弹性。</p>
<p>如果必要的话，使用这些基数。例如将[]Server转化为Servers是另一种抽象，仅在你有一个合理的理由的情况下这么做。不过有一些技术，如 iota 从 1 开始计数总是有用的。再次提醒，永远保持简单。</p>
<p>特别感谢 Cihangir Savas、Andrew Gerrand、Ben Johnson 和 Damian Gryski 提供的极具价值的反馈和建议。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文&lt;a href=&quot;http://mikespook.com/2014/07/%e5%8d%81%e6%9d%a1%e6%9c%89%e7%94%a8%e7%9a%84-go-%e6%8a%80%e6%9c%af/&quot; target=&quot;_blank&quot; rel=&quot;noopen
    
    </summary>
    
      <category term="经验分享" scheme="https://salogs.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
      <category term="Go" scheme="https://salogs.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/Go/"/>
    
    
      <category term="Go" scheme="https://salogs.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>阿里云VPC网络无EIP的主机上网问题</title>
    <link href="https://salogs.com/news/2015/08/02/aliyun-vpc-snat-md/"/>
    <id>https://salogs.com/news/2015/08/02/aliyun-vpc-snat-md/</id>
    <published>2015-08-02T13:38:58.000Z</published>
    <updated>2018-06-19T02:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h1><p>阿里云的VPC与其他基于OpenStack的IaaS不同，他的路由只是作为多网段的路由交换，不提供内到外的路由，因此在VPC内的主机除非绑定EIP，否则是无法连接公网的。通过工单询问客服，得到的结论是通过在路由器上添加一个路由，通过一个绑定EIP的主机做NAT上网，通过设置iptables的方式来实现。</p>
<h1 id="VPC结构图"><a href="#VPC结构图" class="headerlink" title="VPC结构图"></a>VPC结构图</h1><p><img src="/img/aliyun-vpc-snat.jpg" alt=""></p>
<h1 id="虚拟路由器配置"><a href="#虚拟路由器配置" class="headerlink" title="虚拟路由器配置"></a>虚拟路由器配置</h1><h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><p>为了让内网服务器借助EIP访问公网，所以设置所有目标地址0.0.0.0/0下一跳都转发到绑定了公网IP的ECS实例上。这里的下一跳ECS不支持搜索，需要提前记号名称：</p>
<p><img src="/img/aliyun-vpc-snat-2.jpg" alt=""></p>
<h1 id="绑定EIP的主机配置"><a href="#绑定EIP的主机配置" class="headerlink" title="绑定EIP的主机配置"></a>绑定EIP的主机配置</h1><h2 id="iptables添加SNAT规则"><a href="#iptables添加SNAT规则" class="headerlink" title="iptables添加SNAT规则"></a>iptables添加SNAT规则</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING <span class="_">-s</span> 192.168.2.0/24 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> ubuntu 14.04 系统保存iptables设置需要安装iptables-persistent包，然后通过 <code>service iptables-persistent save</code> 的方式保存配置，安装完iptables-persistent后该服务随系统一起启动并会把保存的配置应用</p>
</blockquote>
<h2 id="开启IP转发"><a href="#开启IP转发" class="headerlink" title="开启IP转发"></a>开启IP转发</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.ip_forward=1"</span> &gt;&gt;  /etc/sysctl.conf &amp;&amp; sysctl -p</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class=&quot;headerlink&quot; title=&quot;问题由来&quot;&gt;&lt;/a&gt;问题由来&lt;/h1&gt;&lt;p&gt;阿里云的VPC与其他基于OpenStack的IaaS不同，他的路由只是作为多网段的路由交换，不提供内到外的路由，因此在VPC
    
    </summary>
    
      <category term="经验分享" scheme="https://salogs.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="route" scheme="https://salogs.com/tags/route/"/>
    
      <category term="IaaS" scheme="https://salogs.com/tags/IaaS/"/>
    
  </entry>
  
  <entry>
    <title>shell 数组应用实例</title>
    <link href="https://salogs.com/news/2015/08/02/shell-array-demo/"/>
    <id>https://salogs.com/news/2015/08/02/shell-array-demo/</id>
    <published>2015-08-02T10:01:37.000Z</published>
    <updated>2015-08-02T10:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个空数组</span></span><br><span class="line">Result=()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义并给数组赋值</span></span><br><span class="line">arr=(a b c d e)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>  </p>
<ul>
<li><p>默认数组中的元素是以空格分隔的，如果元素是包含空格的字符串，最好用双引号括起来</p>
</li>
<li><p>shell中的默认分隔符可以通过修改 $IFS变量来设置</p>
</li>
</ul>
</blockquote>
<h1 id="数组读取-删除"><a href="#数组读取-删除" class="headerlink" title="数组读取/删除"></a>数组读取/删除</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化并赋值数组</span></span><br><span class="line">arr=(a b c d e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算长度</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[@]&#125;</span>  <span class="comment"># 结果: 5</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#arr[*]&#125;</span>  <span class="comment"># 结果: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出所有数据</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]&#125;</span>  <span class="comment"># 结果: a b c d e</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[*]&#125;</span>  <span class="comment"># 结果: a b c d e</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出第二个元素的数据</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[1]&#125;</span>  <span class="comment"># 结果: b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数组</span></span><br><span class="line">filelist=(`ls`)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$&#123;filelist[@]&#125;</span>;<span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第二个元素</span></span><br><span class="line"><span class="built_in">unset</span> arr[1]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[*]&#125;</span>  <span class="comment"># 结果: a c d e</span></span><br></pre></td></tr></table></figure>
<h1 id="切片-元素替换"><a href="#切片-元素替换" class="headerlink" title="切片/元素替换"></a>切片/元素替换</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化并赋值数组</span></span><br><span class="line">arr=(a b c d e)</span><br><span class="line"></span><br><span class="line">arr2=(<span class="variable">$&#123;arr[@]:0:3&#125;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr2[@]&#125;</span>  <span class="comment"># 结果 a b c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line"><span class="comment"># 初始化并赋值数组</span></span><br><span class="line">arr=(a b c d e)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]/a/aaa&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>切片(分片):</strong> 直接通过 ${数组名[@或*]:起始位置:长度} 切片原先数组，返回是字符串，中间用“空格”分开，因此如果加上”()”，将得到切片数组，上面例子：c 就是一个新数据。</li>
</ul>
<ul>
<li><strong>替换:</strong> ${数组名[@或*]/查找字符/替换字符} 该操作不会改变原先数组内容，如果需要修改，请重新定义变量并赋值。</li>
</ul>
</blockquote>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><blockquote>
<p>在一个多域名的web server环境中，通过分析访问日志，统计最近8小时有用户访问的域名（去重），并显示。</p>
<p>日志格式：X-Forworld-IP User-IP YYYY-MM-DD HH:mm:ss method “URL” HTTP响应码 服务器处理时间 返回大小 “Refer” “浏览器信息” “虚拟主机域名” 真实处理请求的主机</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">AWKB<span class="keyword">in</span>=<span class="string">"/usr/bin/awk"</span></span><br><span class="line">EGREPB<span class="keyword">in</span>=<span class="string">"/bin/egrep"</span></span><br><span class="line">SORTB<span class="keyword">in</span>=<span class="string">"/usr/bin/sort"</span></span><br><span class="line">SEDB<span class="keyword">in</span>=<span class="string">"/bin/sed"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟主机</span></span><br><span class="line">VSName=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间段</span></span><br><span class="line">TimePeriod=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤字符串</span></span><br><span class="line">FilterKeys=<span class="string">''</span><span class="string">'DNSPod-Monitor|JianKongBao'</span><span class="string">''</span></span><br><span class="line"><span class="comment"># 日志目录</span></span><br><span class="line">LOGPath=<span class="string">"/logs/nginx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义最终输出的数组变量</span></span><br><span class="line">Result=()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (( TimePeriod &gt; 0 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  LogTime=`date <span class="_">-d</span> <span class="string">"- <span class="variable">$&#123;TimePeriod&#125;</span>hours"</span> +%Y-%m-%d-%H`</span><br><span class="line">  LogFile=<span class="variable">$&#123;VSName&#125;</span>_<span class="variable">$&#123;LogTime&#125;</span>.log</span><br><span class="line"></span><br><span class="line">  Result=(<span class="variable">$&#123;Result[@]&#125;</span> `<span class="variable">$AWKBin</span> <span class="string">'&#123;if($5!~/HEAD/ &amp;&amp; $5!~/\"\"/ ) print $0&#125;'</span> <span class="variable">$&#123;LOGPath&#125;</span>/<span class="variable">$&#123;LogFile&#125;</span> | \</span><br><span class="line">         <span class="variable">$EGREPBin</span> -v <span class="variable">$FilterKeys</span> | <span class="variable">$AWKBin</span> <span class="string">'&#123;print $NF&#125;'</span> | <span class="variable">$AWKBin</span> -F <span class="string">'@'</span> <span class="string">'&#123;print $1&#125;'</span> |\</span><br><span class="line">         <span class="variable">$SORTBin</span> -u`)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"第<span class="variable">$TimePeriod</span> 个日志:<span class="variable">$&#123;Result[*]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ((TimePeriod--))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"未去重：<span class="variable">$&#123;Result[*]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">Result=($(awk -vRS=<span class="string">' '</span> <span class="string">'!a[$1]++'</span> &lt;&lt;&lt; <span class="variable">$&#123;Result[@]&#125;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"去重以后:<span class="variable">$&#123;Result[*]&#125;</span>"</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组定义&quot;&gt;&lt;a href=&quot;#数组定义&quot; class=&quot;headerlink&quot; title=&quot;数组定义&quot;&gt;&lt;/a&gt;数组定义&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;
    
    </summary>
    
      <category term="linux" scheme="https://salogs.com/categories/linux/"/>
    
      <category term="script" scheme="https://salogs.com/categories/linux/script/"/>
    
    
      <category term="shell" scheme="https://salogs.com/tags/shell/"/>
    
      <category term="script" scheme="https://salogs.com/tags/script/"/>
    
      <category term="array" scheme="https://salogs.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>salogs正式迁移到github</title>
    <link href="https://salogs.com/news/2015/08/02/migration-to-github/"/>
    <id>https://salogs.com/news/2015/08/02/migration-to-github/</id>
    <published>2015-08-01T16:00:00.000Z</published>
    <updated>2015-08-02T12:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于之前的blog内容过于陈旧，很多文档现在来看会给广大朋友带来困扰，因此决定将之前的所有内容都抛弃，从今天开始重新写！</p>
<p>最近5年由于工作原因也没有顾得上更新blog，近期会有一系列文档更新，都是这五年来的一些工作经验。</p>
<p>由于大家共识的原因，本blog于2015-08-02正式迁移到<a href="https://github.com/zhouyq/zhouyq.github.io" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于之前的blog内容过于陈旧，很多文档现在来看会给广大朋友带来困扰，因此决定将之前的所有内容都抛弃，从今天开始重新写！&lt;/p&gt;
&lt;p&gt;最近5年由于工作原因也没有顾得上更新blog，近期会有一系列文档更新，都是这五年来的一些工作经验。&lt;/p&gt;
&lt;p&gt;由于大家共识的原因，本b
    
    </summary>
    
    
      <category term="其他" scheme="https://salogs.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
